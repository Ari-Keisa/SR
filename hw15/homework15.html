<!DOCTYPE html>
<html lang="uk">
<head>
  <title>–†–æ–±–æ—Ç + MediaPipe Hands + –∂–µ—Å—Ç–∏</title>
  <meta charset="UTF-8">
  <style>
    html, body { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: sans-serif; }
    #video-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
    #output-canvas { width: 100%; height: 100%; object-fit: cover; position: absolute; left: 0; top: 0; z-index: 1; }
    #three-canvas { position: absolute; left: 0; top: 0; width: 100vw; height: 100vh; z-index: 2; pointer-events: none; }
    #controls {
      position: absolute; top: 18px; left: 50%; transform: translateX(-50%);
      z-index: 20; display: flex; flex-direction: column; align-items: center;
      pointer-events: none;
    }
    #gesture {
      background: #ffe066; color: #222; font-size: 2em; border-radius: 8px;
      padding: 4px 18px; margin-bottom: 12px; box-shadow: 0 2px 8px #0003;
      pointer-events: auto;
    }
    #manual-controls {
      background: rgba(30,30,30,0.7);
      border-radius: 14px;
      padding: 8px 18px;
      display: flex;
      gap: 12px;
      box-shadow: 0 2px 12px #0005;
      pointer-events: auto;
    }
    .gesture-btn {
      font-size: 2em; background: none; border: 2px solid #fff; border-radius: 10px; padding: 6px 12px;
      cursor: pointer; transition: background 0.2s, border-color 0.2s, color 0.2s, transform 0.1s;
      color: #fff; box-shadow: 0 1px 4px #0003; position: relative;
    }
    .gesture-btn.active, .gesture-btn:focus {
      background: #ffe066;
      border-color: #ffe066;
      color: #222;
      transform: scale(1.12);
      outline: none;
    }
    .gesture-btn:hover {
      background: #fff3;
      color: #ffe066;
      border-color: #ffe066;
    }
    .gesture-btn.auto {
      border-style: dashed;
      font-size: 1.5em;
      color: #ffe066;
      background: #222;
    }
    /* Tooltip styles */
    .gesture-btn .tooltip {
      display: none;
      position: absolute;
      left: 50%; top: -44px;
      transform: translateX(-50%);
      background: #222;
      color: #ffe066;
      padding: 7px 16px;
      border-radius: 8px;
      font-size: 1em;
      white-space: nowrap;
      box-shadow: 0 2px 8px #0007;
      z-index: 100;
      pointer-events: none;
      opacity: 0.97;
    }
    .gesture-btn:hover .tooltip, .gesture-btn:focus .tooltip {
      display: block;
    }
    @media (max-width: 600px) {
      #manual-controls { gap: 6px; padding: 6px 4px; }
      .gesture-btn { font-size: 1.3em; padding: 4px 6px; }
      #gesture { font-size: 1.3em; padding: 2px 8px; }
      .gesture-btn .tooltip { font-size: 0.9em; }
    }
  </style>
</head>
<body>
  <div id="video-container">
    <video id="input-video" style="display: none;"></video>
    <canvas id="output-canvas"></canvas>
    <canvas id="three-canvas"></canvas>
  </div>
  <div id="controls">
    <div id="gesture">‚úã</div>
    <div id="manual-controls">
      <button class="gesture-btn auto" data-gesture="auto" onclick="setGesture('auto')">
        üß†
        <span class="tooltip">—Å–∫–∏–Ω—É—Ç–∏ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è</span>
      </button>
      <button class="gesture-btn" data-gesture="ok" onclick="setGesture('ok')">
        üëå
        <span class="tooltip">—Ä–æ–±–∏ —Å–∞–ª—å—Ç–æ</span>
      </button>
      <button class="gesture-btn" data-gesture="open" onclick="setGesture('open')">
        ‚úã
        <span class="tooltip">–∑–∞–º—Ä–∏</span>
      </button>
      <button class="gesture-btn" data-gesture="peace" onclick="setGesture('peace')">
        ‚úåÔ∏è
        <span class="tooltip">—Ç–∏–Ω—å-—Ç—É–Ω—å</span>
      </button>
      <button class="gesture-btn" data-gesture="like" onclick="setGesture('like')">
        üëç
        <span class="tooltip">–ø–æ—Å—Ç—Ä–∏–±–∞–π</span>
      </button>
      <button class="gesture-btn" data-gesture="point_left" onclick="setGesture('point_left')">
        üëà
        <span class="tooltip">–ø–æ–∫—Ä—É—Ç–∏—Å—å</span>
      </button>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
  <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
  </script>
  <script type="module">
    import * as THREE from 'three';

    // === Three.js —Ä–æ–±–æ—Ç ===
    const threeCanvas = document.getElementById('three-canvas');
    const renderer = new THREE.WebGLRenderer({canvas: threeCanvas, alpha:true});
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.2, 2.5);

    scene.add(new THREE.AmbientLight(0xffffff, 0.7));
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
    dirLight.position.set(2, 5, 3);
    scene.add(dirLight);

    // –†–æ–±–æ—Ç
    const robot = new THREE.Group();

    // –¢—ñ–ª–æ
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(0.5, 0.7, 0.3),
      new THREE.MeshStandardMaterial({color: 0x8888ff})
    );
    body.position.y = 0.7/2;

    // –ì–æ–ª–æ–≤–∞
    const head = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 32, 32),
      new THREE.MeshStandardMaterial({color: 0xffff88})
    );
    head.position.y = 0.7 + 0.22 + 0.05;

    // –û—á—ñ
    const eyeL = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 16, 16),
      new THREE.MeshStandardMaterial({color: 0x222222})
    );
    eyeL.position.set(-0.06, 0.7 + 0.27, 0.19);

    const eyeR = new THREE.Mesh(
      new THREE.SphereGeometry(0.04, 16, 16),
      new THREE.MeshStandardMaterial({color: 0x222222})
    );
    eyeR.position.set(0.06, 0.7 + 0.27, 0.19);

    // –†–æ—Ç
    const mouth = new THREE.Mesh(
      new THREE.CylinderGeometry(0.05, 0.05, 0.02, 32),
      new THREE.MeshStandardMaterial({color: 0xff4444})
    );
    mouth.position.set(0, 0.7 + 0.18, 0.21);
    mouth.rotation.x = Math.PI/2;

    // –ê–Ω—Ç–µ–Ω–∫–∏
    const antennaL = new THREE.Mesh(
      new THREE.CylinderGeometry(0.01, 0.01, 0.18, 8),
      new THREE.MeshStandardMaterial({color: 0xaaaaaa})
    );
    antennaL.position.set(-0.08, 0.7 + 0.22 + 0.18, 0);
    antennaL.rotation.z = Math.PI/8;

    const antennaR = new THREE.Mesh(
      new THREE.CylinderGeometry(0.01, 0.01, 0.18, 8),
      new THREE.MeshStandardMaterial({color: 0xaaaaaa})
    );
    antennaR.position.set(0.08, 0.7 + 0.22 + 0.18, 0);
    antennaR.rotation.z = -Math.PI/8;

    // –õ—ñ–≤–∞ —Ä—É–∫–∞
    const leftArm = new THREE.Mesh(
      new THREE.CylinderGeometry(0.06, 0.06, 0.5, 24),
      new THREE.MeshStandardMaterial({color: 0x888888})
    );
    leftArm.position.set(-0.32, 0.7, 0);
    leftArm.rotation.z = Math.PI/2;

    // –ü—Ä–∞–≤–∞ —Ä—É–∫–∞
    const rightArm = new THREE.Mesh(
      new THREE.CylinderGeometry(0.06, 0.06, 0.5, 24),
      new THREE.MeshStandardMaterial({color: 0x888888})
    );
    rightArm.position.set(0.32, 0.7, 0);
    rightArm.rotation.z = Math.PI/2;

    robot.add(body, head, eyeL, eyeR, mouth, antennaL, antennaR, leftArm, rightArm);
    scene.add(robot);

    // –ê–Ω—ñ–º–∞—Ü—ñ–π–Ω—ñ —Å—Ç–∞–Ω–∏
    let waveAngle = 0;
    let headTurn = false, headTurnAngle = 0;
    let dance = false, dancePhase = 0;
    let turnLeft = false, turnLeftAngle = 0;
    let flipAngle = 0;

    let currentGesture = 'open'; // ‚úã
    let manualGesture = null; // —è–∫—â–æ –Ω–µ null ‚Äî –º–∞—î –ø—Ä—ñ–æ—Ä–∏—Ç–µ—Ç

    function highlightGesture(gestureName) {
      document.querySelectorAll('.gesture-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.gesture === gestureName);
      });
      document.getElementById('gesture').textContent = {
        ok: 'üëå',
        open: '‚úã',
        peace: '‚úåÔ∏è',
        like: 'üëç',
        point_left: 'üëà',
        auto: 'üß†'
      }[gestureName] || '‚úã';
    }

    // –î–ª—è —Ç–µ—Å—Ç—É: –∫–Ω–æ–ø–∫–∏
    window.setGesture = function(name) {
      if (name === 'auto') {
        manualGesture = null;
        highlightGesture('auto');
      } else {
        manualGesture = name;
        highlightGesture(name);
      }
    };

    function animate() {
      requestAnimationFrame(animate);

      const gesture = manualGesture || currentGesture;

      // üëå ‚Äî —Å–∞–ª—å—Ç–æ (–æ–±–µ—Ä—Ç–∞–Ω–Ω—è –Ω–∞–≤–∫–æ–ª–æ X)
      if (gesture === 'ok') {
        flipAngle += 0.18;
        robot.rotation.x = flipAngle;
        leftArm.rotation.x = -Math.PI/2;
        rightArm.rotation.x = -Math.PI/2;
        mouth.scale.y = 1.2;
        robot.scale.set(1, 1, 1);
      } else {
        flipAngle = 0;
        robot.rotation.x = 0;
      }

      // ‚úåÔ∏è ‚Äî –∫–∞—á–∞—î—Ç—å—Å—è (–º–∞—Å—à—Ç–∞–± –∑–±—ñ–ª—å—à—É—î—Ç—å—Å—è/–∑–º–µ–Ω—à—É—î—Ç—å—Å—è, –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ)
      if (gesture === 'peace') {
        dancePhase += 0.045; // –ø–æ–≤—ñ–ª—å–Ω—ñ—à–µ!
        const scale = 1 + 0.3 * Math.sin(dancePhase * 1.5);
        robot.scale.set(scale, scale, scale);
        leftArm.rotation.x = -Math.PI/2;
        rightArm.rotation.x = -Math.PI/2;
        mouth.scale.y = 1.5;
      } else if (gesture !== 'ok') {
        robot.scale.set(1, 1, 1);
      }

      // ‚úã ‚Äî –ø—ñ–¥–Ω—è—Ç–∏ –æ–±–∏–¥–≤—ñ —Ä—É–∫–∏
      if (gesture === 'open') {
        leftArm.rotation.x = -Math.PI/2;
        rightArm.rotation.x = -Math.PI/2;
        mouth.scale.y = 1;
      }

      // üëç ‚Äî "–ª–∞–π–∫": —Ä–æ–±–æ—Ç —Å—Ç—Ä–∏–±–∞—î —ñ –º–∞—Ö–∞—î –æ–±–æ–º–∞ —Ä—É–∫–∞–º–∏
      if (gesture === 'like') {
        dance = true;
        dancePhase += 0.12;
        robot.position.y = Math.abs(Math.sin(dancePhase)) * 0.25;
        leftArm.rotation.x = Math.sin(dancePhase) * 0.8 - Math.PI/2;
        rightArm.rotation.x = Math.cos(dancePhase) * 0.8 - Math.PI/2;
        mouth.scale.y = 2;
      } else if (!dance && gesture !== 'ok') {
        robot.position.y = 0;
      }

      // üëà ‚Äî –ø–æ–≤–µ—Ä—Ç–∞—î—Ç—å—Å—è –≤–ª—ñ–≤–æ
      if (gesture === 'point_left') {
        turnLeft = true;
        turnLeftAngle += 0.05;
        robot.rotation.y = Math.sin(turnLeftAngle) * 0.7;
        mouth.scale.y = 0.7;
      } else if (gesture !== 'point_left' && gesture !== 'ok') {
        turnLeft = false;
        turnLeftAngle = 0;
        robot.rotation.y = 0;
      }

      renderer.setSize(window.innerWidth, window.innerHeight, false);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener('resize', () => {
      renderer.setSize(window.innerWidth, window.innerHeight, false);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
    });

    // === MediaPipe Hands ===
    const videoElement = document.getElementById('input-video');
    const canvasElement = document.getElementById('output-canvas');
    const canvasCtx = canvasElement.getContext('2d');

    function isFingerOpen(landmarks, tip, pip, mcp, handedness) {
      if (tip === 4) { // Thumb
        if (handedness === 'Right') {
          return landmarks[tip].x < landmarks[mcp].x - 0.02;
        } else {
          return landmarks[tip].x > landmarks[mcp].x + 0.02;
        }
      } else {
        return landmarks[tip].y < landmarks[pip].y && landmarks[pip].y < landmarks[mcp].y;
      }
    }

    function distance(a, b) {
      return Math.sqrt(
        (a.x - b.x) ** 2 +
        (a.y - b.y) ** 2 +
        (a.z - b.z) ** 2
      );
    }

    function getGestureByFingers(landmarks, handedness) {
      if (!landmarks) return null;
      const fingers = [
        isFingerOpen(landmarks, 4, 3, 2, handedness),   // Thumb
        isFingerOpen(landmarks, 8, 7, 5, handedness),   // Index
        isFingerOpen(landmarks, 12,11,9, handedness),   // Middle
        isFingerOpen(landmarks, 16,15,13, handedness),  // Ring
        isFingerOpen(landmarks, 20,19,17, handedness)   // Pinky
      ];
      // OK: –∫—ñ–Ω—á–∏–∫–∏ –≤–µ–ª–∏–∫–æ–≥–æ —ñ –≤–∫–∞–∑—ñ–≤–Ω–æ–≥–æ –¥—É–∂–µ –±–ª–∏–∑—å–∫–æ (—ñ–Ω—à—ñ –ø–∞–ª—å—Ü—ñ –º–æ–∂—É—Ç—å –±—É—Ç–∏ —Ä–æ–∑–∫—Ä–∏—Ç—ñ)
      const okDist = distance(landmarks[4], landmarks[8]);
      if (okDist < 0.07) return 'ok';
      // ‚úã ‚Äî –≤—Å—ñ –ø–∞–ª—å—Ü—ñ —Ä–æ–∑–∫—Ä–∏—Ç—ñ
      if (fingers.every(f => f)) return 'open';
      // ‚úåÔ∏è ‚Äî –≤–∫–∞–∑—ñ–≤–Ω–∏–π —ñ —Å–µ—Ä–µ–¥–Ω—ñ–π open, —ñ–Ω—à—ñ closed
      if (!fingers[0] && fingers[1] && fingers[2] && !fingers[3] && !fingers[4]) return 'peace';
      // üëç ‚Äî —Ç—ñ–ª—å–∫–∏ –≤–µ–ª–∏–∫–∏–π open
      if (fingers[0] && !fingers[1] && !fingers[2] && !fingers[3] && !fingers[4]) return 'like';
      // üëà ‚Äî —Ç—ñ–ª—å–∫–∏ –≤–∫–∞–∑—ñ–≤–Ω–∏–π open
      if (!fingers[0] && fingers[1] && !fingers[2] && !fingers[3] && !fingers[4]) return 'point_left';
      return null;
    }

    function onResults(results) {
      const width = canvasElement.width;
      const height = canvasElement.height;

      canvasCtx.save();
      canvasCtx.clearRect(0, 0, width, height);
      canvasCtx.drawImage(results.image, 0, 0, width, height);

      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        const handedness = results.multiHandedness[0]?.label || 'Right';

        window.drawConnectors(canvasCtx, landmarks, window.HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
        window.drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });

        // === –†–æ–∑–ø—ñ–∑–Ω–∞–≤–∞–Ω–Ω—è –∂–µ—Å—Ç—É –ø–æ –ø–∞–ª—å—Ü—è—Ö ===
        const gesture = getGestureByFingers(landmarks, handedness);
        if (!manualGesture && gesture && gesture !== currentGesture) {
          currentGesture = gesture;
          highlightGesture(gesture);
        }
      }
      canvasCtx.restore();
    }

    const hands = new window.Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5,
      selfieMode: true,
    });

    hands.onResults(onResults);

    async function startCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: { ideal: 1280 }, height: { ideal: 720 } }
      });
      videoElement.srcObject = stream;

      videoElement.onloadedmetadata = () => {
        videoElement.play();
        canvasElement.width = videoElement.videoWidth;
        canvasElement.height = videoElement.videoHeight;
        threeCanvas.width = videoElement.videoWidth;
        threeCanvas.height = videoElement.videoHeight;
        sendToMediaPipe();
      };
    }

    async function sendToMediaPipe() {
      if (videoElement.readyState >= 2) {
        await hands.send({ image: videoElement });
      }
      requestAnimationFrame(sendToMediaPipe);
    }

    startCamera();
    highlightGesture(currentGesture);
  </script>
</body>
</html>